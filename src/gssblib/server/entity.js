/**
 * Simple module for representing tables as Entity objects with CRUD methods.
 *
 * Each Entity represents a single table (not a row, that is, an Entity is a
 * table data gateway) which is assumed to have an autogenenerated 'id' column.
 *
 * An Entity offers the following CRUD methods ('get', 'find', and 'read' being
 * the read methods):
 *
 *   create: inserts a new object
 *   get:    retrieves a single object, throws error if not found
 *   find:   looks for a single object, returns undefined if not found
 *   read:   select objects
 *   update: updates an existing object
 *   remove: removes an object
 *
 * All methods return a promise of the object(s) being manipulated and database
 * errors are propagated.
 * 
 * Usage:
 *
 *   var db = require('mysqlq'),
 *       entity = require('entity');
 *
 *   var items = entity(db, 'person', ['first_name', 'last_name']);
 *
 *   items.create({first_name: 'Homer', last_name: 'Simpson'}).then(
 *     function (person) {
 *       // person.id will contain autogenerated id
 *     },
 *     function (err) {
 *       // ...
 *     });
 *
 *   items.read({first_name: 'Homer'}).then(
 *     function (persons) {
 *     });
 */

function dbEscape(name) { return '`' + name + '`'; }

/**
 * Simple class providing the CRUD services for a single table.
 *
 * The config contains:
 *
 *   name: Name of the entity
 *   tableName: optional name of the underlying table, falls back to name
 *   columns: list of columns (see below)
 *   naturalKey: optional name of the natural key column
 *
 * A column is either just the column name or an object with a
 * 'name' property and an optimal 'queryOp' property specifying the
 * default comparison operation (see see the sqlTerm method below).
 */
function Entity(db, config) {
  var self = this;
  this.db = db;
  this.name = config.name;
  this.table = dbEscape(config.tableName || config.name);
  this.columnsByName = {};
  this.columns = config.columns.map(function (column) {
    if (typeof(column) !== 'object') column = {name: column};
    self.columnsByName[column.name] = column;
    return column;
  });
  this.naturalKey = config.naturalKey;
}

/**
 * Returns the promise of saving a new object in the table.
 */
Entity.prototype.create = function (obj) {
  var self = this;
  var columns = [];
  var placeholders = [];
  var params = [];

  self.columns.forEach(function (column) {
    var value = obj[column.name];
    if (value !== undefined) {
      columns.push(column.name);
      placeholders.push('?');
      params.push(value);
    }
  });
  var sql = 'insert into ' + self.table +
    ' (' + columns.join(', ') + ') values (' + placeholders.join(', ') + ')';
  return self.db.query(sql, params).then(function (data) {
    // node-mysql returns the auto increment primary key in the 'insertId' field.
    obj.id = data[0].insertId;
    return obj;
  });
};

/**
 * Creates a SQL term (comparison in a where clause) for a single field.
 */
Entity.prototype.sqlTerm = function(field, value) {
  var column = this.columnsByName[field];
  if (column === undefined) {
    return undefined;
  }
  var op = (column && column.queryOp) || 'equals';

  if (typeof(value) === 'object') {
    op = value.op;
    value = value.value;
  }

  if (op === 'contains') {
    return {field: field, op: 'like', value: '%' + value + '%'};
  } else if (op === 'startwith') {
    return {field: field, op: 'like', value: value + '%'};
  } else if (op === 'endswith') {
    return {field: field, op: 'like', value: '%' + value};
  } else {
    return {field: field, op: '=', value: value};
  }
};

/**
 * Translates a query to an array of terms.
 */
Entity.prototype.sqlTerms = function(query) {
  var terms = [];
  if (query !== undefined) {
    if (typeof(query) !== 'object') {
      var value = query;
      query = {};
      query[this.naturalKey || 'id'] = value;
    }
    for (var name in query) {
      if (query.hasOwnProperty(name)) {
        var term = this.sqlTerm(name, query[name]);
        if (term) {
          terms.push(term);
        }
      }
    }
  }
  return terms;
};

/**
 * Constructs the where clause and parameter array for the query.
 */
Entity.prototype.sqlWhere = function(query) {
  var terms = this.sqlTerms(query);
  var sql = '';
  var params = [];
  if (terms.length !== 0) {
    sql += ' where ';
    terms.forEach(function (clause, index) {
      if (index > 0) sql += ' and ';
      sql += clause.field + ' ' + clause.op + ' ?';
      params.push(clause.value);
    });
  }
  return {sql: sql, params: params};
};

/**
 * Returns the promise of a single object (row) identified by the query or
 * undefined if not found.
 */
Entity.prototype.find = function (query) {
  var whereClause = this.sqlWhere(query);
  var sql = 'select * from ' + this.table + whereClause.sql;
  return this.db.selectRow(sql, whereClause.params);
};

/**
 * Returns the promise of a single object (row) identified by the query.
 */
Entity.prototype.get = function (query) {
  var self = this;
  return self.constructor.prototype.find.call(self, query).then(function (data) {
    if (data === undefined) {
      throw { httpStatusCode: 400, code: 'ENTITY_NOT_FOUND' };
    }
    return data;
  });
};

/**
 * Returns the promise of the objects (rows) identified by the query.
 */
Entity.prototype.read = function (query, limit) {
  var whereClause = this.sqlWhere(query);
  var sql = 'select * from ' + this.table + whereClause.sql;
  return this.db.selectRows(sql, whereClause.params, limit);
};

/**
 * Returns the promise of updating an existing object. The object (that
 * is, its id) must already exist in the table.
 */
Entity.prototype.update = function (obj) {
  var self = this;
  var params = [];
  var sql = '';
  self.columns.forEach(function (column) {
    var value = obj[column.name];
    if (value !== undefined) {
      if (sql.length > 0) sql += ', ';
      sql += column.name + ' = ?';
      params.push(value);
    }
  });
  sql = 'update ' + self.table + ' set ' + sql + ' where id = ?';
  params.push(obj.id);
  return self.db.query(sql, params);
};

/**
 * Returns the promise of deleting an object identified by id.
 */
Entity.prototype.remove = function (id) {
  return this.db.query('delete from ' + this.table + ' where id = ?', id);
};

module.exports = function (db, config) {
  return new Entity(db, config);
};

